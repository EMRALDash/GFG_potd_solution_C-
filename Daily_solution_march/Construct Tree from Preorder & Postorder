class Solution {
  public:
    int preIndex = 0;

    Node* constructTreeUtil(vector<int>& pre, vector<int>& post, int l, int r) {
        if (preIndex >= pre.size() || l > r)
            return nullptr;

        // Create root node with current preorder element
        Node* root = new Node(pre[preIndex++]);

        // If the current subtree has only one node
        if (l == r || preIndex >= pre.size())
            return root;

        // The next element in preorder is the left child
        int leftVal = pre[preIndex];

        // Find index of left child in postorder
        int i;
        for (i = l; i <= r; i++) {
            if (post[i] == leftVal)
                break;
        }

        // Build left and right subtrees
        if (i <= r) {
            root->left = constructTreeUtil(pre, post, l, i);
            root->right = constructTreeUtil(pre, post, i + 1, r - 1);
        }

        return root;
    }

    Node* constructTree(vector<int>& pre, vector<int>& post) {
        preIndex = 0;
        return constructTreeUtil(pre, post, 0, post.size() - 1);
    }
};
