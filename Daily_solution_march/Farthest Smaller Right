#include <bits/stdc++.h>
using namespace std;

class Solution {
  public:
    vector<int> farMin(vector<int>& arr) {
        int n = arr.size();
        vector<int> res(n, -1);

        // Coordinate compression of values
        vector<int> vals = arr;
        sort(vals.begin(), vals.end());
        vals.erase(unique(vals.begin(), vals.end()), vals.end());

        auto getIdx = [&](int x) {
            return int(lower_bound(vals.begin(), vals.end(), x) - vals.begin()) + 1; // 1-based
        };

        // Fenwick tree storing max index
        struct BIT {
            int N; vector<int> t;
            BIT(int n): N(n), t(n+1, -1) {}
            void update(int i, int val) {
                for (; i <= N; i += i & -i) t[i] = max(t[i], val);
            }
            int query(int i) {
                int ans = -1;
                for (; i > 0; i -= i & -i) ans = max(ans, t[i]);
                return ans;
            }
        } bit((int)vals.size());

        // Traverse from right to left
        for (int i = n - 1; i >= 0; --i) {
            int idx = getIdx(arr[i]);
            // query strictly smaller values => up to idx - 1
            res[i] = bit.query(idx - 1);
            // update current value with the rightmost index i
            bit.update(idx, i);
        }
        return res;
    }
};
